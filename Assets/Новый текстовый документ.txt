    public void HighlightAvailableTiles(Vector3 selectedUnitPos, int moveDistance, Enums.UniteType unitType)
    {
        int xPos = (int)selectedUnitPos.x;
        int zPos = (int)selectedUnitPos.z;

        for (int i = 1; i <= moveDistance; i++)
        {
            for (int j = 1; j <= moveDistance; j++)
            {
                if (unitType == Enums.UniteType.Pawn) // Pawn Movement
                {
                    if (xPos + i < _gridRows)
                    {
                        highlight.Add(_tilePos[xPos + i, zPos]);
                    }

                    if (xPos - i >= 0)
                    {
                        highlight.Add(_tilePos[xPos - i, zPos]);
                    }

                    if (zPos - j >= 0)
                    {
                        highlight.Add(_tilePos[xPos, zPos - j]);
                    }

                    if (zPos + j < _gridColumns)
                    {
                        highlight.Add(_tilePos[xPos, zPos + j]);
                    }
                }

                if (unitType == Enums.UniteType.Knight) // Knight movement
                {
                    if (i == moveDistance)
                    {
                        if (xPos - i >= 0 && zPos + 1 < _gridColumns)
                        {
                            highlight.Add(_tilePos[xPos - i, zPos + 1]);
                        }

                        if (xPos - i >= 0 && zPos - 1 >= 0)
                        {
                            highlight.Add(_tilePos[xPos - i, zPos - 1]);
                        }

                        if (xPos + i < _gridRows && zPos + 1 < _gridColumns)
                        {
                            highlight.Add(_tilePos[xPos + i, zPos + 1]);
                        }

                        if (xPos + i < _gridRows && zPos - 1 >= 0)
                        {
                            highlight.Add(_tilePos[xPos + i, zPos - 1]);
                        }
                    }

                    if (j == moveDistance)
                    {
                        if (zPos - j >= 0 && xPos + 1 < _gridRows)
                        {
                            highlight.Add(_tilePos[xPos + 1, zPos - j]);
                        }

                        if (zPos - j >= 0 && xPos - 1 >= 0)
                        {
                            highlight.Add(_tilePos[xPos - 1, zPos - j]);
                        }

                        if (zPos + j < _gridColumns && xPos + 1 < _gridRows)
                        {
                            highlight.Add(_tilePos[xPos + 1, zPos + j]);
                        }

                        if (zPos + j < _gridColumns && xPos - 1 >= 0)
                        {
                            highlight.Add(_tilePos[xPos - 1, zPos + j]);
                        }
                    }
                }

                if (unitType == Enums.UniteType.Bishop) // Bishop movement
                {
                    if (xPos + i < _gridRows && zPos + i < _gridColumns)
                    {
                        highlight.Add(_tilePos[xPos + i, zPos + i]);
                    }

                    if (xPos - i >= 0 && zPos - i >= 0)
                    {
                        highlight.Add(_tilePos[xPos - i, zPos - i]);
                    }

                    if (xPos - j >= 0 && zPos + j < _gridColumns)
                    {
                        highlight.Add(_tilePos[xPos - j, zPos + j]);
                    }

                    if (xPos + j < _gridRows && zPos - j >= 0)
                    {
                        highlight.Add(_tilePos[xPos + j, zPos - j]);
                    }
                }

                if (unitType == Enums.UniteType.Rook) // Rook movement
                {
                    if (xPos + i < _gridRows)
                    {
                        highlight.Add(_tilePos[xPos + i, zPos]);
                    }

                    if (xPos - i >= 0)
                    {
                        highlight.Add(_tilePos[xPos - i, zPos]);
                    }

                    if (zPos - j >= 0)
                    {
                        highlight.Add(_tilePos[xPos, zPos - j]);
                    }

                    if (zPos + j < _gridColumns)
                    {
                        highlight.Add(_tilePos[xPos, zPos + j]);
                    }
                }

                if (unitType == Enums.UniteType.Queen) // Queen movement
                {
                    if (xPos + i < _gridRows)
                    {
                        highlight.Add(_tilePos[xPos + i, zPos]);
                    }

                    if (xPos - i >= 0)
                    {
                        highlight.Add(_tilePos[xPos - i, zPos]);
                    }

                    if (zPos - j >= 0)
                    {
                        highlight.Add(_tilePos[xPos, zPos - j]);
                    }

                    if (zPos + j < _gridColumns)
                    {
                        highlight.Add(_tilePos[xPos, zPos + j]);
                    }

                    if (xPos + i < _gridRows && zPos + i < _gridColumns)
                    {
                        highlight.Add(_tilePos[xPos + i, zPos + i]);
                    }

                    if (xPos - i >= 0 && zPos - i >= 0)
                    {
                        highlight.Add(_tilePos[xPos - i, zPos - i]);
                    }

                    if (xPos - j >= 0 && zPos + j < _gridColumns)
                    {
                        highlight.Add(_tilePos[xPos - j, zPos + j]);
                    }

                    if (xPos + j < _gridRows && zPos - j >= 0)
                    {
                        highlight.Add(_tilePos[xPos + j, zPos - j]);
                    }
                }
            }
        }

        for (int i = 0; i < highlight.Count; i++)
        {
            highlight[i].GetComponent<MeshRenderer>().material = _defaultAvailableTile;
            highlight[i].layer = LayerMask.NameToLayer("AvailableTile");
        }
    }

    public void HideAvailableTile()
    {
        for (int i = 0; i < highlight.Count; i++)
        {
            highlight[i].GetComponent<MeshRenderer>().material = _tileMaterials[i];
            highlight[i].layer = LayerMask.NameToLayer("Tile");
        }

        for (int i = 0; i < tiles.Count; i++)
        {
            tiles[i].GetComponent<MeshRenderer>().material = _tileMaterials[i];
        }
        highlight.Clear();
    }